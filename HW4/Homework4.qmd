---
title: "Homework 4 - HPC and SQL"
author: "Chih-Chan (Jessica) Lan"
format: 
  html:
    embed-resources: true
editor: visual
---
# HPC

## Make things run faster
Rewrite the following R functions to make them faster. It is OK (and recommended) to take a look at StackOverflow and Google.

- `fun1`: Find the total for each row of a numeric matrix. Output should be a vector with length equal to the number of rows of the input matrix.
- `fun2`: Calculate the running (cumulative) total along each row of a numeric matrix. Output should be a matrix with dimensions equal to the input matrix.

```{r}
# Total for each row
fun1 <- function(mat) {
  n <- nrow(mat)
  ans <- double(n) 
  for (i in 1:n) {
    ans[i] <- sum(mat[i, ])
  }
  ans
}

fun1alt <- function(mat) {
  ans <- rowSums(mat)
}

# running cumulative sum by row
fun2 <- function(mat) {
  n <- nrow(mat)
  k <- ncol(mat)
  ans <- mat
  for (i in 1:n) {
    for (j in 2:k) {
      ans[i,j] <- mat[i, j] + ans[i, j - 1]
    }
  }
  ans
}

fun2alt <- function(mat) {
  ans <- t(apply(mat, 1, cumsum))
}
```

## Question 1
```{r}
# Use the data with this code
set.seed(2315)
dat <- matrix(rnorm(200 * 100), nrow = 200)
```

```{r}
# Test for the first
microbenchmark::microbenchmark(
  fun1(dat),
  fun1alt(dat), unit = "relative"
)
```

When using the alternative function as the reference, we can see that the original method takes roughly 15 times longer to run based on the average relative runtime. This indicates that the alternative method is more efficient and performs faster than the original approach.

```{r}
# Test for the second
microbenchmark::microbenchmark(
  fun2(dat),
  fun2alt(dat), unit = "relative"
)
```
When using the alternative function as the reference, we can see that the original method takes roughly 3 times longer to run based on the average relative runtime. This indicates that the alternative method is more efficient and performs faster than the original approach.

## Make things run faster with parallel computing

```{r}
sim_pi <- function(n = 1000, i = NULL) {
  p <- matrix(runif(n*2), ncol = 2)
  mean(rowSums(p^2) < 1) * 4
}

# Here is an example of the run
set.seed(156)
sim_pi(1000) # 3.132
```

```{r}
# This runs the simulation a 4,000 times, each with 10,000 points
set.seed(1231)
system.time({
  ans <- unlist(lapply(1:4000, sim_pi, n = 10000))
  print(mean(ans))
})
```

## Question 2
```{r}
library(parallel)

# Create cluster
no_cores <- detectCores() - 1
cl <- makeCluster(no_cores)
clusterExport(cl, "sim_pi")

set.seed(1231)
system.time({
  ans <- unlist(parLapply(cl, 1:4000, sim_pi, n = 10000))
  print(mean(ans))
})

stopCluster(cl)
```



# SQL
```{r}
# install.packages(c("RSQLite", "DBI"))

library(RSQLite)
library(DBI)

# Initialize a temporary in memory database
con <- dbConnect(SQLite(), ":memory:")

# Download tables
film <- read.csv("https://raw.githubusercontent.com/ivanceras/sakila/master/csv-sakila-db/film.csv")
film_category <- read.csv("https://raw.githubusercontent.com/ivanceras/sakila/master/csv-sakila-db/film_category.csv")
category <- read.csv("https://raw.githubusercontent.com/ivanceras/sakila/master/csv-sakila-db/category.csv")

# Copy data.frames to database
dbWriteTable(con, "film", film)
dbWriteTable(con, "film_category", film_category)
dbWriteTable(con, "category", category)
```

```{sql connection=con}
PRAGMA table_info(category)
```

```{sql connection=con}
PRAGMA table_info(film)
```

```{sql connection=con}
PRAGMA table_info(film_category)
```

## Question 3
How many movies are available in each `rating` category?
```{sql connection=con}
SELECT a.rating, count(a.film_id) as cnt
FROM film as a
GROUP BY a.rating
```

## Question 4
What is the average replacement cost and rental rate for each `rating` category?
```{sql connection=con}
SELECT a.rating,
  avg(a.replacement_cost) as mean_replacement_cost,
  avg(a.rental_rate) as mean_rental_rate
FROM film as a
GROUP BY a.rating
```

## Question 5
Use table `film_category` together with `film` to find how many films there are with each category ID.
```{sql connection=con}
SELECT b.category_id, count(a.film_id) as cnt
FROM film as a
  INNER JOIN film_category as b ON a.film_id = b.film_id
GROUP BY b.category_id
```

## Question 6
Incorporate the `category` table into the answer to the previous question to find the name of the most popular category.

Ans: Sports
```{sql connection=con}
SELECT b.category_id, c.name as category_name, count(a.film_id) as cnt
FROM film as a
  INNER JOIN film_category as b ON a.film_id = b.film_id
  LEFT JOIN category as c ON b.category_id = c.category_id
GROUP BY b.category_id
ORDER BY cnt DESC
```


```{r}
# clean up
dbDisconnect(con)
```

